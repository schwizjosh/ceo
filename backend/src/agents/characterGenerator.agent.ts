/**
 * CHARACTER GENERATOR AGENT
 *
 * Creates rich, detailed brand personas/characters with depth and creativity
 * Uses premium AI models for maximum creativity and personality
 */

import { BaseAgent, AgentInput, AgentOutput, AIModel } from './base';
import {
  CHARACTER_GENERATION_SYSTEM_PROMPT,
  buildCharacterGenerationPrompt,
  CHARACTER_REFINEMENT_PROMPT
} from '../utils/prompts/character.prompts';
import { aiService } from '../services/aiService';

interface CharacterGeneratorInput extends AgentInput {
  context: {
    brandName: string;
    brandTagline: string;
    brandVoice: string;
    brandPersonality: string[];
    industry: string;
    targetAudience?: string;
    buyerProfile?: string; // Structured buyer profile with lifestyle, casual interests, aspirations
    brandValues?: string[];
    numberOfCharacters?: number; // How many to generate (default 3)
    existingCharacters?: any[]; // To avoid duplicates
    specificRole?: string; // If generating a specific character type
    fallbackModels?: AIModel[]; // Models to try if primary model fails
  };
}

interface CharacterOutput {
  name: string; // Real name from user input (e.g., "Josh", "Starr")
  character_name: string; // Dramatic role generated by AI (e.g., "The Guardian", "The Sage")
  role: string;
  personality: string; // One-line personality with optional 16personalities.com type
  description: string;
  backstory: string;
  voice: string; // Character & Voice - comprehensive description
  archetype: string;
  location: string;
  day_of_week: string;
  speaking_style: string;
  quirks: string[];
  relationships: string;
  growth_arc: string;
  content_strengths: string[];
  sample_quotes: string[];
}

/**
 * Character Generator Agent
 *
 * Uses GPT-4o by default for balanced creativity and cost
 */
export class CharacterGeneratorAgent extends BaseAgent {
  constructor(model?: AIModel) {
    super({
      name: 'CharacterGenerator',
      model: model || 'gpt-4o', // Standardize default to GPT-4o
      defaultTokenBudget: 3000, // More tokens for detailed personas
      description: 'Generates rich, detailed brand personas with depth',
      capabilities: ['character-creation', 'persona-refinement', 'archetype-design']
    });
  }

  /**
   * Main execution: Generate brand characters/personas
   */
  async execute(input: CharacterGeneratorInput): Promise<AgentOutput<CharacterOutput[]>> {
    this.validateInput(input);
    this.startTimer();

    const { context } = input;
    const numCharacters = context.numberOfCharacters || 3;

    this.log('Generating characters', {
      brand: context.brandName,
      count: numCharacters,
      industry: context.industry
    });

    try {
      // Use custom task if provided, otherwise build default prompt
      const userPrompt = input.task || buildCharacterGenerationPrompt({
        brandName: context.brandName,
        brandIndustry: context.industry,
        characterCount: numCharacters,
        hints: [], // Could pass user hints in the future
        existingCharacters: context.existingCharacters,
        targetAudience: context.targetAudience,
        buyerProfile: context.buyerProfile || context.targetAudience // Use buyerProfile if available, fallback to targetAudience
      });

      // Replace template variables in system prompt
      const systemPrompt = CHARACTER_GENERATION_SYSTEM_PROMPT
        .replace('{{brandName}}', context.brandName)
        .replace('{{brandIndustry}}', context.industry)
        .replace('{{brandTagline}}', context.brandTagline)
        .replace('{{brandPersonality}}', context.brandPersonality.join(', '))
        .replace('{{brandValues}}', context.brandValues?.join(', ') || 'Not specified')
        .replace('{{targetAudience}}', context.targetAudience || 'General audience')
        .replace('{{brandVoice}}', context.brandVoice)
        .replace('{{channels}}', 'Instagram, X, LinkedIn, Facebook'); // Could be dynamic

      // Call AI with fallbacks (passed from orchestrator or empty array)
      this.log('Calling AI model', { model: this.config.model });
      console.log('üìù SYSTEM PROMPT:', systemPrompt.substring(0, 500));
      console.log('üìù USER PROMPT:', userPrompt.substring(0, 500));

      // Add explicit JSON format reminder to user prompt
      const jsonEnforcedPrompt = userPrompt + '\n\nüö® CRITICAL: Return ONLY valid JSON starting with { and ending with }. NO markdown, NO prose, NO explanations. Just pure JSON.';

      const fallbackModels = context.fallbackModels || [];
      const result = await this.callAI(systemPrompt, jsonEnforcedPrompt, fallbackModels);

      // Parse and validate result
      const characters = this.parseCharacterOutput(result);

      this.log('Characters generated successfully', {
        count: characters.length,
        names: characters.map(c => c.name).join(', ')
      });

      return this.createOutput(characters, this.estimateTokens(systemPrompt, userPrompt, result));

    } catch (error) {
      this.log('Error generating characters', error);
      throw error;
    }
  }

  /**
   * Generate a single character with specific role
   */
  async generateSingleCharacter(input: {
    brandName: string;
    brandVoice: string;
    brandPersonality: string[];
    role: string;
    existingCharacters?: any[];
  }): Promise<AgentOutput<CharacterOutput>> {
    this.startTimer();

    const prompt = `Generate a single, deeply developed brand character for ${input.brandName}.

ROLE REQUIREMENT: ${input.role}

Brand Voice: ${input.brandVoice}
Brand Personality: ${input.brandPersonality.join(', ')}

Existing Characters (avoid duplication): ${input.existingCharacters?.map(c => c.name).join(', ') || 'None'}

Follow the CHARACTER DEVELOPMENT FRAMEWORK from the system prompt to create this character with full depth and authenticity.

OUTPUT FORMAT: Return a JSON object with all character fields.`;

    try {
      const result = await this.callAI(CHARACTER_GENERATION_SYSTEM_PROMPT, prompt);
      const character = this.parseSingleCharacterOutput(result);

      return this.createOutput(character, this.estimateTokens(CHARACTER_GENERATION_SYSTEM_PROMPT, prompt, result));
    } catch (error) {
      this.log('Error generating single character', error);
      throw error;
    }
  }

  /**
   * Refine existing character based on user feedback
   */
  async refineCharacter(input: {
    character: CharacterOutput;
    userInstructions: string;
    brandContext: {
      brandName: string;
      brandVoice: string;
      brandPersonality: string[];
    };
  }): Promise<AgentOutput<CharacterOutput>> {
    this.startTimer();

    const prompt = CHARACTER_REFINEMENT_PROMPT
      .replace('{{characterData}}', JSON.stringify(input.character, null, 2))
      .replace('{{userInstructions}}', input.userInstructions)
      .replace('{{brandName}}', input.brandContext.brandName)
      .replace('{{brandVoice}}', input.brandContext.brandVoice)
      .replace('{{brandPersonality}}', input.brandContext.brandPersonality.join(', '));

    try {
      const result = await this.callAI(CHARACTER_GENERATION_SYSTEM_PROMPT, prompt);
      const refinedCharacter = this.parseSingleCharacterOutput(result);

      this.log('Character refined successfully', { name: refinedCharacter.name });

      return this.createOutput(refinedCharacter, this.estimateTokens(CHARACTER_GENERATION_SYSTEM_PROMPT, prompt, result));
    } catch (error) {
      this.log('Error refining character', error);
      throw error;
    }
  }

  /**
   * Call AI model with actual API integration (with smart fallbacks)
   */
  private async callAI(systemPrompt: string, userPrompt: string, fallbackModels?: AIModel[]): Promise<string> {
    try {
      // Use specified model with fallbacks for resilience
      const response = await aiService.generate({
        model: this.config.model,
        systemPrompt,
        userPrompt,
        maxTokens: this.config.defaultTokenBudget,
        temperature: 0.9, // High creativity for character generation
        retries: 2, // 2 retries per model
        fallbackModels: fallbackModels || [] // Fallback models if primary fails
      });

      this.log('AI call successful', {
        model: response.model,
        tokensUsed: response.tokensUsed,
        duration: response.duration,
        cost: response.cost
      });

      return response.content;
    } catch (error) {
      this.log('Error calling AI API', error);
      throw new Error(`AI API call failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Parse and validate AI output for multiple characters
   */
  private parseCharacterOutput(response: string): CharacterOutput[] {
    try {
      // Strip markdown code blocks and headers
      let cleanResponse = response.trim();

      // Remove markdown code blocks (```json ... ```)
      cleanResponse = cleanResponse.replace(/^```(?:json)?\s*/i, '').replace(/```\s*$/i, '');

      // Remove all markdown headers and emphasis
      cleanResponse = cleanResponse.replace(/^#+\s+.+$/gm, '');
      cleanResponse = cleanResponse.replace(/^\*\*.+\*\*$/gm, '');
      cleanResponse = cleanResponse.replace(/^\*.+$/gm, ''); // Remove lines starting with *
      cleanResponse = cleanResponse.replace(/^---+$/gm, ''); // Remove horizontal rules

      // Remove leading/trailing whitespace
      cleanResponse = cleanResponse.trim();

      // If the response doesn't look like JSON at all (starts with prose/markdown)
      // Try to find JSON buried in the response
      if (!cleanResponse.startsWith('{') && !cleanResponse.startsWith('[')) {
        console.warn('‚ö†Ô∏è  AI returned prose instead of JSON. Attempting to extract JSON...');

        // Try to find a JSON object or array in the response
        const jsonMatch = cleanResponse.match(/\{[\s\S]*"characters"[\s\S]*\}/);
        if (!jsonMatch) {
          // Last resort: look for ANY valid JSON structure
          const anyJsonMatch = cleanResponse.match(/(\{[\s\S]*?\}|\[[\s\S]*?\])/);
          if (anyJsonMatch) {
            cleanResponse = anyJsonMatch[1];
          } else {
            throw new Error('AI returned prose instead of JSON. No JSON structure found in response.');
          }
        } else {
          cleanResponse = jsonMatch[0];
        }
      }

      // Try to extract and balance JSON braces
      const jsonStr = cleanResponse.trim();
      const parsed = JSON.parse(jsonStr);

      // Handle both array and single object responses
      const charactersArray = Array.isArray(parsed) ? parsed :
        parsed.characters ? parsed.characters :
          [parsed];

      // Validate each character
      const validatedCharacters: CharacterOutput[] = charactersArray.map((char: any) => {
        // Flexible field mapping - AI might use different field names
        const description = char.description || char.story || char.backstory || char.persona || '';
        const role = char.role || char.title || char.position || 'Team Member';

        // AI returns: char.name = dramatic role, char.character_name = real name
        // Frontend expects: name = real name, character_name = dramatic role
        // So we need to SWAP these values

        // Get the dramatic role from AI (what AI calls "name")
        let dramaticRole = char.name || 'The Guide';

        // Get the real name from AI (what AI calls "character_name" or "real_name")
        const realName = char.character_name || char.real_name || '';

        if (!dramaticRole || dramaticRole.trim() === '') {
          console.warn('‚ö†Ô∏è  AI returned character without dramatic role, using default: "The Guide"');
          dramaticRole = 'The Guide';
        }
        if (!description) {
          console.warn('‚ö†Ô∏è  AI returned character without description, this character may be incomplete');
        }

        // üö® CRITICAL: NARRATIVE PRINCIPLE - THE CUSTOMER IS THE HERO, NOT THE BRAND CHARACTER
        // If AI returns "Hero" in the dramatic role, replace it with "Guide" (narrative framework principle)
        if (dramaticRole && /\bHero\b/i.test(dramaticRole)) {
          console.warn(`‚ö†Ô∏è  AI returned forbidden name "${dramaticRole}" - replacing with "The Guide" (narrative framework principle)`);
          dramaticRole = dramaticRole.replace(/\bThe Hero\b/i, 'The Guide')
            .replace(/\bHero\b/i, 'Guide');
        }

        return {
          name: realName, // Real name from AI (user's input like "Josh", "Starr") - stays empty if not provided
          character_name: dramaticRole, // Dramatic role from AI (e.g., "The Guardian", "The Sage")
          role: role,
          personality: char.personality || char.voice || 'Authentic and engaging professional',
          description: description,
          backstory: char.backstory || char.story || description,
          voice: char.voice || char.speaking_style || char.signature || 'Professional and engaging voice with authentic connection',
          archetype: char.archetype || 'The Guide', // Changed from 'The Hero' - customer is the hero!
          location: char.location || char.work_mode || 'Headquarters',
          day_of_week: char.day_of_week || this.assignDayOfWeek(charactersArray.indexOf(char)),
          speaking_style: char.speaking_style || char.voice || 'Professional and conversational',
          quirks: Array.isArray(char.quirks) ? char.quirks : [],
          relationships: char.relationships || '',
          growth_arc: char.growth_arc || char.motivation || '',
          content_strengths: Array.isArray(char.content_strengths) ? char.content_strengths :
            (Array.isArray(char.expertise) ? char.expertise : []),
          sample_quotes: Array.isArray(char.sample_quotes) ? char.sample_quotes :
            (char.signature ? [char.signature] : [])
        };
      });

      return validatedCharacters;
    } catch (error) {
      this.log('Error parsing character output', error);
      this.log('Raw response', response);
      throw new Error(`Failed to parse character data: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Parse single character output
   */
  private parseSingleCharacterOutput(response: string): CharacterOutput {
    const characters = this.parseCharacterOutput(response);
    if (characters.length === 0) {
      throw new Error('No character data in response');
    }
    return characters[0];
  }

  /**
   * Assign day of week based on index
   */
  private assignDayOfWeek(index: number): string {
    const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    return days[index % days.length];
  }

  /**
   * Estimate tokens used (rough approximation)
   */
  private estimateTokens(system: string, user: string, response: string): number {
    const totalChars = system.length + user.length + response.length;
    return Math.ceil(totalChars / 4); // ~4 chars per token
  }
}
